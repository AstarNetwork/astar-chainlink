{
  "language": "Solidity",
  "sources": {
    "contracts/AggregatorProxy.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport \"@chainlink/contracts/src/v0.7/dev/AggregatorProxy.sol\";\n"
    },
    "@chainlink/contracts/src/v0.7/dev/AggregatorProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"../ConfirmedOwner.sol\";\nimport \"../interfaces/AggregatorProxyInterface.sol\";\n\n/**\n * @title A trusted proxy for updating where current answers are read from\n * @notice This contract provides a consistent address for the\n * CurrentAnswerInterface but delegates where it reads from to the owner, who is\n * trusted to update it.\n */\ncontract AggregatorProxy is AggregatorProxyInterface, ConfirmedOwner {\n  struct Phase {\n    uint16 id;\n    AggregatorProxyInterface aggregator;\n  }\n  AggregatorProxyInterface private s_proposedAggregator;\n  mapping(uint16 => AggregatorProxyInterface) private s_phaseAggregators;\n  Phase private s_currentPhase;\n\n  uint256 private constant PHASE_OFFSET = 64;\n  uint256 private constant PHASE_SIZE = 16;\n  uint256 private constant MAX_ID = 2**(PHASE_OFFSET + PHASE_SIZE) - 1;\n\n  event AggregatorProposed(address indexed current, address indexed proposed);\n  event AggregatorConfirmed(address indexed previous, address indexed latest);\n\n  constructor(address aggregatorAddress) ConfirmedOwner(msg.sender) {\n    setAggregator(aggregatorAddress);\n  }\n\n  /**\n   * @notice Reads the current answer from aggregator delegated to.\n   *\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\n   * answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended latestRoundData\n   * instead which includes better verification information.\n   */\n  function latestAnswer() public view virtual override returns (int256 answer) {\n    return s_currentPhase.aggregator.latestAnswer();\n  }\n\n  /**\n   * @notice Reads the last updated height from aggregator delegated to.\n   *\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\n   * answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended latestRoundData\n   * instead which includes better verification information.\n   */\n  function latestTimestamp() public view virtual override returns (uint256 updatedAt) {\n    return s_currentPhase.aggregator.latestTimestamp();\n  }\n\n  /**\n   * @notice get past rounds answers\n   * @param roundId the answer number to retrieve the answer for\n   *\n   * @dev #[deprecated] Use getRoundData instead. This does not error if no\n   * answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended getRoundData\n   * instead which includes better verification information.\n   */\n  function getAnswer(uint256 roundId) public view virtual override returns (int256 answer) {\n    if (roundId > MAX_ID) return 0;\n\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\n    AggregatorProxyInterface aggregator = s_phaseAggregators[phaseId];\n    if (address(aggregator) == address(0)) return 0;\n\n    return aggregator.getAnswer(aggregatorRoundId);\n  }\n\n  /**\n   * @notice get block timestamp when an answer was last updated\n   * @param roundId the answer number to retrieve the updated timestamp for\n   *\n   * @dev #[deprecated] Use getRoundData instead. This does not error if no\n   * answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended getRoundData\n   * instead which includes better verification information.\n   */\n  function getTimestamp(uint256 roundId) public view virtual override returns (uint256 updatedAt) {\n    if (roundId > MAX_ID) return 0;\n\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\n    AggregatorProxyInterface aggregator = s_phaseAggregators[phaseId];\n    if (address(aggregator) == address(0)) return 0;\n\n    return aggregator.getTimestamp(aggregatorRoundId);\n  }\n\n  /**\n   * @notice get the latest completed round where the answer was updated. This\n   * ID includes the proxy's phase, to make sure round IDs increase even when\n   * switching to a newly deployed aggregator.\n   *\n   * @dev #[deprecated] Use latestRoundData instead. This does not error if no\n   * answer has been reached, it will simply return 0. Either wait to point to\n   * an already answered Aggregator or use the recommended latestRoundData\n   * instead which includes better verification information.\n   */\n  function latestRound() public view virtual override returns (uint256 roundId) {\n    Phase memory phase = s_currentPhase; // cache storage reads\n    return addPhase(phase.id, uint64(phase.aggregator.latestRound()));\n  }\n\n  /**\n   * @notice get data about a round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @param roundId the requested round ID as presented through the proxy, this\n   * is made up of the aggregator's round ID with the phase ID encoded in the\n   * two highest order bytes\n   * @return id is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function getRoundData(uint80 roundId)\n    public\n    view\n    virtual\n    override\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    (uint16 phaseId, uint64 aggregatorRoundId) = parseIds(roundId);\n\n    (id, answer, startedAt, updatedAt, answeredInRound) = s_phaseAggregators[phaseId].getRoundData(aggregatorRoundId);\n\n    return addPhaseIds(id, answer, startedAt, updatedAt, answeredInRound, phaseId);\n  }\n\n  /**\n   * @notice get data about the latest round. Consumers are encouraged to check\n   * that they're receiving fresh data by inspecting the updatedAt and\n   * answeredInRound return values.\n   * Note that different underlying implementations of AggregatorV3Interface\n   * have slightly different semantics for some of the return values. Consumers\n   * should determine what implementations they expect to receive\n   * data from and validate that they can properly handle return data from all\n   * of them.\n   * @return id is the round ID from the aggregator for which the data was\n   * retrieved combined with an phase to ensure that round IDs get larger as\n   * time moves forward.\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @dev Note that answer and updatedAt may change between queries.\n   */\n  function latestRoundData()\n    public\n    view\n    virtual\n    override\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    Phase memory current = s_currentPhase; // cache storage reads\n\n    (id, answer, startedAt, updatedAt, answeredInRound) = current.aggregator.latestRoundData();\n\n    return addPhaseIds(id, answer, startedAt, updatedAt, answeredInRound, current.id);\n  }\n\n  /**\n   * @notice Used if an aggregator contract has been proposed.\n   * @param roundId the round ID to retrieve the round data for\n   * @return id is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   */\n  function proposedGetRoundData(uint80 roundId)\n    external\n    view\n    virtual\n    override\n    hasProposal\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return s_proposedAggregator.getRoundData(roundId);\n  }\n\n  /**\n   * @notice Used if an aggregator contract has been proposed.\n   * @return id is the round ID for which data was retrieved\n   * @return answer is the answer for the given round\n   * @return startedAt is the timestamp when the round was started.\n   * (Only some AggregatorV3Interface implementations return meaningful values)\n   * @return updatedAt is the timestamp when the round last was updated (i.e.\n   * answer was last computed)\n   * @return answeredInRound is the round ID of the round in which the answer\n   * was computed.\n   */\n  function proposedLatestRoundData()\n    external\n    view\n    virtual\n    override\n    hasProposal\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return s_proposedAggregator.latestRoundData();\n  }\n\n  /**\n   * @notice returns the current phase's aggregator address.\n   */\n  function aggregator() external view override returns (address) {\n    return address(s_currentPhase.aggregator);\n  }\n\n  /**\n   * @notice returns the current phase's ID.\n   */\n  function phaseId() external view override returns (uint16) {\n    return s_currentPhase.id;\n  }\n\n  /**\n   * @notice represents the number of decimals the aggregator responses represent.\n   */\n  function decimals() external view override returns (uint8) {\n    return s_currentPhase.aggregator.decimals();\n  }\n\n  /**\n   * @notice the version number representing the type of aggregator the proxy\n   * points to.\n   */\n  function version() external view override returns (uint256) {\n    return s_currentPhase.aggregator.version();\n  }\n\n  /**\n   * @notice returns the description of the aggregator the proxy points to.\n   */\n  function description() external view override returns (string memory) {\n    return s_currentPhase.aggregator.description();\n  }\n\n  /**\n   * @notice returns the current proposed aggregator\n   */\n  function proposedAggregator() external view override returns (address) {\n    return address(s_proposedAggregator);\n  }\n\n  /**\n   * @notice return a phase aggregator using the phaseId\n   *\n   * @param phaseId uint16\n   */\n  function phaseAggregators(uint16 phaseId) external view override returns (address) {\n    return address(s_phaseAggregators[phaseId]);\n  }\n\n  /**\n   * @notice Allows the owner to propose a new address for the aggregator\n   * @param aggregatorAddress The new address for the aggregator contract\n   */\n  function proposeAggregator(address aggregatorAddress) external onlyOwner {\n    s_proposedAggregator = AggregatorProxyInterface(aggregatorAddress);\n    emit AggregatorProposed(address(s_currentPhase.aggregator), aggregatorAddress);\n  }\n\n  /**\n   * @notice Allows the owner to confirm and change the address\n   * to the proposed aggregator\n   * @dev Reverts if the given address doesn't match what was previously\n   * proposed\n   * @param aggregatorAddress The new address for the aggregator contract\n   */\n  function confirmAggregator(address aggregatorAddress) external onlyOwner {\n    require(aggregatorAddress == address(s_proposedAggregator), \"Invalid proposed aggregator\");\n    address previousAggregator = address(s_currentPhase.aggregator);\n    delete s_proposedAggregator;\n    setAggregator(aggregatorAddress);\n    emit AggregatorConfirmed(previousAggregator, aggregatorAddress);\n  }\n\n  /*\n   * Internal\n   */\n\n  function setAggregator(address aggregatorAddress) internal {\n    uint16 id = s_currentPhase.id + 1;\n    s_currentPhase = Phase(id, AggregatorProxyInterface(aggregatorAddress));\n    s_phaseAggregators[id] = AggregatorProxyInterface(aggregatorAddress);\n  }\n\n  function addPhase(uint16 phase, uint64 originalId) internal pure returns (uint80) {\n    return uint80((uint256(phase) << PHASE_OFFSET) | originalId);\n  }\n\n  function parseIds(uint256 roundId) internal pure returns (uint16, uint64) {\n    uint16 phaseId = uint16(roundId >> PHASE_OFFSET);\n    uint64 aggregatorRoundId = uint64(roundId);\n\n    return (phaseId, aggregatorRoundId);\n  }\n\n  function addPhaseIds(\n    uint80 roundId,\n    int256 answer,\n    uint256 startedAt,\n    uint256 updatedAt,\n    uint80 answeredInRound,\n    uint16 phaseId\n  )\n    internal\n    pure\n    returns (\n      uint80,\n      int256,\n      uint256,\n      uint256,\n      uint80\n    )\n  {\n    return (\n      addPhase(phaseId, uint64(roundId)),\n      answer,\n      startedAt,\n      updatedAt,\n      addPhase(phaseId, uint64(answeredInRound))\n    );\n  }\n\n  /*\n   * Modifiers\n   */\n\n  modifier hasProposal() {\n    require(address(s_proposedAggregator) != address(0), \"No proposed aggregator present\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.7/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorProxyInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface AggregatorProxyInterface is AggregatorV2V3Interface {\n  function phaseAggregators(uint16 phaseId) external view returns (address);\n\n  function phaseId() external view returns (uint16);\n\n  function proposedAggregator() external view returns (address);\n\n  function proposedGetRoundData(uint80 roundId)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData()\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function aggregator() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.7/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}